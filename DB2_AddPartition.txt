#!/bin/ksh
#
# usage : add_partitions.sh <DBNAME>  
#
#==========================================================================
#clear 

DBNAME=$1
TABSCHEMA=INTPRV
TABNAME=MESSAGELOG
FREQUENCY=W
echo "Add partition for $TABSCHEMA.$TABNAME"

MAX_TIMEPERIOD=30                     #Max number of days to preallocate partitions

if [ "$#" = 1 ]
then
  echo Load DB2 Profile...
  . ~/sqllib/db2profile
else
  echo "Not enough parameters"
  echo "Usage : $0 <DBNAME>  "
  echo " "
  exit 1
fi

DBNAME=`echo $DBNAME | tr [a-z] [A-Z]`
HOSTNAME=`hostname -s`
TMSTAMP=`date +%Y%m%d_%H%M`
DTSTAMP=`date +%Y%m%d`
 
SCRIPTDIR=`dirname "$0"`
SCRIPTLOG="$SCRIPTDIR"/logs/PartitionAddArch_"$HOSTNAME"_"$DBNAME"_"$DTSTAMP".log       #All messages written during execution of script
ERR_FLAG=N
mkdir -p "$SCRIPTDIR/logs"

#====================================================================================================================================
echo "***********************************************************************************************************"  
echo "*        ADD Partition to $TABSCHEMA.$TABNAME table on $HOSTNAME ( $DBNAME ) at $TMSTAMP                  *"   
echo "***********************************************************************************************************"  
echo "Script Executing     : $0"                                                                             	    
echo "Log written to       : $SCRIPTLOG"                                                                            

# Connect to database
echo DBNAME             : $DBNAME |tee -a "$SCRIPTLOG" 
db2 -v connect to $DBNAME                                                                                           
RETCODE=$?
if [ "$RETCODE" -gt 0 ]
then
   echo "ERROR : Could not connect to database $DBNAME"                                                              
   exit 1
else
    PERIODDESCR=Weekly
    PERIODNAME=Week                                     
    echo "Table: $TABSCHEMA.$TABNAME..Add New $PERIODDESCR Partition Starting $PERIODNAME at $START_DATE .. @ `date` .." |tee -a $SCRIPTLOG 
				 
    echo "Verify if Table is Partitioned"  
    db2 -x "select count(*)  
            from syscat.tables
            where tabschema = '"$TABSCHEMA"'
                AND tabname = '"$TABNAME"'
            and tbspace is null
            and type = 'T'" | read IS_PARTITIONED DUMMY

    echo IS_PARTITIONED : $IS_PARTITIONED | tee -a $SCRIPTLOG 
    if [ "$IS_PARTITIONED" = 0 ]
    then
        echo "Table is not Partitioned" |tee -a $SCRIPTLOG
        exit 0
    fi

    echo "Determine the HIGHVALUE of the last partition, but only use it if it is after today"
    db2 -x "select max(COALESCE(max(date(substr(HIGHVALUE,2,10))), CURRENT_DATE),CURRENT_DATE)
            from SYSCAT.DATAPARTITIONS
            where tabschema = '$TABSCHEMA'
                AND tabname = '$TABNAME'"

    db2 -x "select max(COALESCE(max(date(substr(HIGHVALUE,2,10))), CURRENT_DATE),CURRENT_DATE)
            from SYSCAT.DATAPARTITIONS
            where tabschema = '$TABSCHEMA'
                AND tabname = '$TABNAME'" |read START_DATE DUMMY

    echo TABSCHEMA          : $TABSCHEMA |tee -a $SCRIPTLOG
    echo TABNAME            : $TABNAME |tee -a $SCRIPTLOG
    echo START_DATE         : $START_DATE |tee -a $SCRIPTLOG 

    echo "Get the first part of the TBspace Name before the first underscore character"       # based on Naming Convention <abcdefg"_"YYpp"1_DATA">
 
    db2 -x "select substr(tbspace,1,locate('_',tbspace)-1) , datatype, pagesize 
            from syscat.tablespaces
            where tbspaceid =  (select max(tbspaceid)
                                from SYSCAT.DATAPARTITIONS  
                                where tabschema = '$TABSCHEMA'
                                AND tabname = '$TABNAME'
                               )" | read SHORT_NAME TS_TYPE TS_PGSZ DUMMY 

    echo TS SHORT_NAME      : $SHORT_NAME  |tee -a $SCRIPTLOG
    echo TS_TYPE            : $TS_TYPE |tee -a $SCRIPTLOG
    echo TS_PGSZ            : $TS_PGSZ |tee -a $SCRIPTLOG

 
    db2 -x "values YEAR('$START_DATE')"|read START_YEAR DUMMY
    db2 -x "values MONTH('$START_DATE')" |read START_MONTH DUMMY
    db2 -x "values DAY('$START_DATE')" |read START_DAY DUMMY
  
    db2 -x "values WEEK_ISO('"$START_YEAR"-"$START_MONTH"-"$START_DAY"')"|read START_WEEK DUMMY
 
    db2 -x "values date('"$START_YEAR"-"$START_MONTH"-"$START_DAY"') + (8 - DAYOFWEEK_ISO('"$START_YEAR"-"$START_MONTH"-"$START_DAY"') ) DAYS"|read END_DATE DUMMY  # Always End the Week on Sunday;-- irrespective of where it starts
    db2 -x "values YEAR('$END_DATE')"|read  END_YEAR DUMMY
    db2 -x "values MONTH('$END_DATE')"|read END_MONTH DUMMY
    db2 -x "values DAY('$END_DATE')"|read END_DAY DUMMY

    echo START_YEAR         : $START_YEAR  |tee -a $SCRIPTLOG
    echo START_MONTH        : $START_MONTH |tee -a $SCRIPTLOG
    echo START_DAY          : $START_DAY   |tee -a $SCRIPTLOG
   
    echo START_WEEK         : $START_WEEK |tee -a $SCRIPTLOG
     
    echo END_DATE           : $END_DATE  |tee -a $SCRIPTLOG 
    echo END_YEAR           : $END_YEAR |tee -a $SCRIPTLOG
    echo END_MONTH          : $END_MONTH |tee -a $SCRIPTLOG
    echo END_DAY            : $END_DAY |tee -a $SCRIPTLOG

 
    ST="$START_YEAR"-"$START_MONTH"-"$START_DAY"
    EN="$END_YEAR"-"$END_MONTH"-"$END_DAY"

    PART_NAME="P""$FREQUENCY""$START_YEAR""$START_WEEK"

    TS_NAME="$SHORT_NAME"_"$START_YEAR""$START_WEEK""_DATA"
    IX_NAME="$SHORT_NAME"_"$START_YEAR""$START_WEEK""_IX"
    LOB_NAME="$SHORT_NAME"_"$START_YEAR""$START_WEEK""_LOB"
 

    db2 -x "values JULIAN_DAY('"$START_YEAR"-"$START_MONTH"-"$START_DAY"')" |read JULIAN_START_DAY DUMMY   
    db2 -x "values JULIAN_DAY(CURRENT_DATE)" |read JULIAN_CURRENT_DAY DUMMY
    echo JULIAN_START_DAY   : $JULIAN_START_DAY     
    echo JULIAN_CURRENT_DAY : $JULIAN_CURRENT_DAY

    (( JULIAN_DAYS = JULIAN_START_DAY - JULIAN_CURRENT_DAY ))


    echo JULIAN_DAYS        : $JULIAN_DAYS |tee -a $SCRIPTLOG

    echo MAX_TIMEPERIOD     : $MAX_TIMEPERIOD |tee -a $SCRIPTLOG

    echo PART START TS      : $ST  |tee -a $SCRIPTLOG
    echo PART END TS        : $EN |tee -a $SCRIPTLOG

    echo PART_NAME          : $PART_NAME |tee -a $SCRIPTLOG
    echo TS_NAME            : $TS_NAME |tee -a $SCRIPTLOG
    echo IX_NAME            : $IX_NAME |tee -a $SCRIPTLOG
    echo LOB_NAME           : $LOB_NAME |tee -a $SCRIPTLOG



 										  
    #Only allow Partitions be added up to 3 months in advance (max)
    if [ "$JULIAN_DAYS" -lt "$MAX_TIMEPERIOD" ]
    then
        db2 -v "CALL DBATB.CREATE_DATA_TS('"$TS_NAME"','"$TS_TYPE"','"$TS_PGSZ"')"
        RETCODE=$?
        if [ "$RETCODE" -gt 0 ]
        then
	    echo Create DATA tablespace Return Code: "$RETCODE" 								|tee -a $SCRIPTLOG
            ERR_FLAG="Y"
	    exit 1
        fi
	 db2 -v "CALL DBATB.CREATE_IX_TS('"$IX_NAME"')"
        RETCODE=$?
	if [ "$RETCODE" -gt 0 ]
        then
	    echo Create INDEX tablespace Return Code: "$RETCODE" 								|tee -a $SCRIPTLOG
	    ERR_FLAG="Y"
	    exit 1
        fi
   
        db2 -x "SELECT count(*) FROM SYSCAT.COLUMNS WHERE TYPENAME IN ('BLOB', 'CLOB') AND TABNAME = '"$TABNAME"' AND TABSCHEMA = '"$TABSCHEMA"' " |read BLOB_CNT DUMMY
        echo BLOB_CNT          : $BLOB_CNT
	if [ "$BLOB_CNT" -gt 0 ]
	then 
	    db2 -v "CALL DBATB.CREATE_BLOB_TS('$LOB_NAME')"
            RETCODE=$?
	    if [ "$RETCODE" -gt 0 ]
            then
	        echo Create BLOB tablespace Return Code: "$RETCODE" 								|tee -a $SCRIPTLOG
         	exit 1
            fi
	    DB2_STATEMENT="ALTER TABLE "$TABSCHEMA"."$TABNAME" ADD PARTITION "$PART_NAME" STARTING ( '"$ST"' ) ENDING ('"$EN"' ) EXCLUSIVE IN "$TS_NAME" INDEX IN "$IX_NAME" LONG IN "$LOB_NAME""
        else 
	    DB2_STATEMENT="ALTER TABLE "$TABSCHEMA"."$TABNAME" ADD PARTITION "$PART_NAME" STARTING ( '"$ST"' ) ENDING ('"$EN"' ) EXCLUSIVE IN "$TS_NAME" INDEX IN "$IX_NAME""
        fi 
        echo DB2_STATEMENT : $DB2_STATEMENT |tee -a $SCRIPTLOG
        db2 -v $DB2_STATEMENT  >> $SCRIPTLOG
        RETCODE=$?
	if [ "$RETCODE" -gt 0 ]
	then
            echo Add Partition Return Code: "$RETCODE" 								|tee -a $SCRIPTLOG
            ERR_FLAG="Y"
	    echo "Error adding new partition to table $TABSCHEMA.$TABNAME. Contact DB2 DBA on Standby" 	|tee -a $SCRIPTLOG
	    echo "============================>>> Failed Statement <<<====================================== " 	|tee -a $SCRIPTLOG
	    tail -7 $SCRIPTLOG 			
	    echo "============================>>> End of Statement <<<====================================== " 	|tee -a $SCRIPTLOG
	fi
    else
        echo "Not creating partitions $MAX_TIMEPERIOD days in advance"                                           |tee -a $SCRIPTLOG
    fi
fi

if [ "$ERR_FLAG" = "Y" ]
then
    echo "One or more errors have occured with adding data partitions. Please contact DB2 DBA on Standby" 					| tee -a $SCRIPTLOG
    exit 4
else
    echo "Success " | tee -a $SCRIPTLOG
    echo "======================================= THE END ====================================" |tee -a $SCRIPTLOG 
fi
 more $SCRIPTLOG
exit 0
